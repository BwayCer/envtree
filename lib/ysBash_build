#!/bin/bash
# 執行環境建立文件


##shStyle ###


source shbase "#loxog"


##shStyle 介面函式


fnYsBash_build() {
    local _fileName="$1"
    local ysPathArge="$2"
    local plantHomeArge="$3"
    local envCodeArge=$4
    local ysBashBuildPath="$5"
    local onlyLine="$6"

    if [ ! -f "$ysBashBuildPath" ]; then
        loxog -f "$_fileName" war \
            "環境樹未被建立，請執行 \`$_fileName plant\`。"
        exit 1
    fi

    if [ -z "`cat "$ysBashBuildPath"`" ]; then
        exit
    fi

    ysPath=$ysPathArge
    plantHome="$plantHomeArge"
    envCode=$envCodeArge

    echo
    echo "=============================="
    echo "===    執行環境安裝文件    ==="
    echo "=============================="
    echo

    local line filePath readFilePath
    local lineIdx=0
    while read line
    do
        ((lineIdx++))
        [ -n "$line" ] && [ "${line::1}" != "#" ] || continue
        [ -n "$onlyLine" ] && [ -z "`grep -Fo ",$lineIdx," <<< ",$onlyLine,"`" ] \
            && continue || echo -n

        fnReplaceHome "$line"
        filePath="$rtnReplaceHome"

        echo "$_br$_br=== $filePath ===$_br"

        # 文件路徑資訊
        __filename=`realpath "$filePath"`
        _dirsh=`dirname "$__filename"`
        _fileName=`basename "$__filename"`

        # 於執行文件中可使用外層既有的變數 (類似 source)
        # 但文件中設定的變數不會影響外層變數
        echo "$filePath" |
            while read readFilePath; do source "$readFilePath" "$readFilePath"; done
    done <<< "`cat "$ysBashBuildPath"`"
}


##shStyle 共享變數


_br="
"

ysPath=""
plantHome=""
envCode=-1


##shStyle 函式庫


rtnReplaceHome=""
fnReplaceHome() {
    local filePathArgu="$1"

    local filePath
    local originTxt='$HOME/'

    if [ "${filePathArgu::${#originTxt}}" == "${originTxt}" ]; then
        filePath="$HOME/${filePathArgu:${#originTxt}}"
    else
        filePath="$filePathArgu"
    fi

    rtnReplaceHome=$filePath
}

fnLinkUserdir() {
    local dirPath=$1

    [ -d "$ysUserdirPath" ] || return

    local sourcePath

    find "$dirPath" -maxdepth 1 | sed "1d" | while read sourcePath
    do
        fnLink_getHomeLnkPath "$sourcePath"
        ln -sf "$fnLink_rtnGetHomeLnkPath" "$HOME"
    done
}
fnLinkList() {
    local infoTxt="$1"

    local line sourcePath targetPath
    local homeTxt="${HOME}/"

    while read line
    do
        sourcePath=`cut -d " " -f 2- <<< "$line"`
        targetPath=`cut -d " " -f 1  <<< "$line"`

        if [ "${sourcePath::${#homeTxt}}" == "$homeTxt" ] &&
            ([ "${targetPath::${#homeTxt}}" == "$homeTxt" ] &&
             [ "`sed "s/[^\/]//g" <<< "$targetPath"`" == "///" ]);
        then
            fnLink_getHomeLnkPath "$sourcePath"
            ln -sf "$fnLink_rtnGetHomeLnkPath" "$targetPath"
        else
            ln -sf "$sourcePath" "$targetPath"
        fi
    done <<< "`grep "." <<< "$infoTxt" | sed "s/ ----*= / /g"`"
}
fnLink_rtnGetHomeLnkPath=""
fnLink_getHomeLnkPath() {
    local queryPath="$1"

    local execFilePath
    local ysDirPathLength=$((${#ysPath} + 1))

    if [ "${queryPath::$ysDirPathLength}" == "${ysPath}/" ]; then
        execFilePath="./ys/${queryPath:$ysDirPathLength}"
    else
        execFilePath="$queryPath"
    fi

    fnLink_rtnGetHomeLnkPath=$execFilePath
}


##shStyle ###


fnYsBash_build "$@"

