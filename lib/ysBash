#!/bin/bash
# Ys 命令環境


##shStyle ###


source shbase.redirection.sh
source shbase "#abase"
source shbase "pathRelative.lib.sh"


##shStyle ###


shScript_route() {
    case "$1" in
    info         ) _shCmdLevel=1 ;
        case "$2" in
        parseConfig  ) _shCmdLevel=2 ;;
        platformCode ) _shCmdLevel=2 ;;
        esac ;;
    plant        ) _shCmdLevel=1 ;
        case "$2" in
        build        ) _shCmdLevel=2 ;;
        setBashrc    ) _shCmdLevel=2 ;;
        esac ;;
    which        ) _shCmdLevel=1 ;;
    edit         ) _shCmdLevel=1 ;;
    createModule ) _shCmdLevel=1 ;;
    esac
}


##shStyle 介面函式


showHelpRecord "main" "\
環境樹設置
[[USAGE]]
[[SUBCMD]]
  info           [[BRIEFLY:info]]
  plant          [[BRIEFLY:plant]]
  which          [[BRIEFLY:which]]
  edit           [[BRIEFLY:edit]]
  createModule   [[BRIEFLY:createModule]]
[[OPT]]
  -h, --help   幫助。
"
# fnOpt_main() {}
fnSh_main() {
    showHelp "$_fileName"
}

showHelpRecord "main_info" "\
顯示資訊。
[[USAGE]]
[[SUBCMD]]
  parseConfig    [[BRIEFLY:parseConfig]]
  platformCode   [[BRIEFLY:platformCode]]
[[OPT]]
  -h, --help   幫助。
"
fnOpt_main_info() {
    case "$1" in
        -h | --help ) showHelp "$_fileName" ;;
        * ) parseOption_shift=3 ;;
    esac
}
fnSh_main_info() {
    parseOption "$_fileName"
    showHelp "$_fileName"
}

showHelpRecord "main_info_parseConfig" "\
解析設定文件。
[[USAGE]]
[[OPT]]
  -p, --pureTxt          取消表格顯示。
  -y, --ysPath           顯示 Ys 目錄路徑。
  -e, --envCode <code>   過濾環境代碼。
  -c, --command <command[,...]                            過濾命令。
                  (IMPORT|LINK|PATH|SRCMD|OTHERBySelf)>
  -h, --help             幫助。
"
fnOpt_main_info_parseConfig() {
    local tmp
    case "$1" in
        -p | --pureTxt )
            opt_pureTxt=1
            parseOption_shift=1
            ;;
        -y | --ysPath )
            opt_isSetGrepOpt=1
            opt_ysPath=1
            parseOption_shift=1
            ;;
        -e | --envCode )
            [ -z "$2" ] && parseOption_shift=4

            opt_envCode=$2
            parseOption_shift=2
            ;;
        -c | --command )
            tmp="\(IMPORT\|LINK\|PATH\|SRCMD\|OTHERBySelf\)"
            [ -z "`grep "^$tmp\(,$tmp\)*$" <<< "$2"`" ] && parseOption_shift=4

            opt_isSetGrepOpt=1
            tmp="$2"

            if [ -n "`grep ",OTHERBySelf," <<< ",$tmp,"`" ]; then
                opt_command_otherBySelf=1
                tmp=`sed "s/OTHERBySelf//" <<< "$tmp"`
            fi

            opt_command_args=(`tr "," " " <<< "$tmp"`)
            parseOption_shift=2
            ;;
        -h | --help ) showHelp "$_fileName" ;;
        * ) parseOption_shift=3 ;;
    esac
}
fnSh_main_info_parseConfig() {
    opt_pureTxt=0
    opt_envCode=$allowAllPlatformCode
    opt_isSetGrepOpt=0
    opt_ysPath=0
    opt_command_args=()
    opt_command_otherBySelf=0
    parseOption "$_fileName"

    local len
    local commandTxt otherBySelfTxt
    local outputTemplate=""
    local outputArgsList=()

    if [ $opt_isSetGrepOpt -eq 0 ]; then
        opt_ysPath=1
        opt_command_args=("IMPORT" "LINK" "PATH" "SRCMD")
        opt_command_otherBySelf=1
    fi

    fnParseProFileConfig "$configPath"
    commandTxt="$rtnParseProFileConfig_commandTxt"
    otherBySelfTxt="$rtnParseProFileConfig_otherBySelfTxt"

    if [ -n "$commandTxt" ]; then
        if [ $opt_envCode -ne 0 ]; then
            commandTxt=`fnParseProFileConfig_filterEnvCode $opt_envCode <<< "$commandTxt"`
            commandTxt+=$_br
        fi
        if [ ${#opt_command_args[@]} -ne 0 ]; then
            commandTxt=`fnParseProFileConfig_sortTxt "${opt_command_args[@]}" \
                <<< "$commandTxt"`
            commandTxt+=$_br
        fi
        commandTxt=`printf "$commandTxt"`
    fi

    if [ $opt_ysPath -eq 1 ]; then
        [ $opt_pureTxt -eq 0 ] \
            && outputTemplate+="\"ysPath\" 路徑： %s\n" \
            || outputTemplate+="%s\n"
        outputArgsList[${#outputArgsList[@]}]=$ysPath
    fi
    if [ ${#opt_command_args[@]} -ne 0 ]; then
        len=${#outputArgsList[@]}
        if [ $opt_pureTxt -eq 0 ]; then
            outputTemplate+="規範命令：\n%s\n"
            [ -n "$commandTxt" ] \
                && outputArgsList[$len]=`cat -n <<< "$commandTxt"` \
                || outputArgsList[$len]="    ~~ 空白 ~~"
        elif [ -n "$commandTxt" ]; then
            outputTemplate+="%s\n"
            outputArgsList[$len]=$commandTxt
        fi
    fi
    if [ "$opt_command_otherBySelf" -eq 1 ]; then
        len=${#outputArgsList[@]}
        if [ $opt_pureTxt -eq 0 ]; then
            outputTemplate+="\"OTHER BySelf\" 命令：\n%s\n"
            [ -n "$otherBySelfTxt" ] \
                && outputArgsList[$len]=`cat -n <<< "$otherBySelfTxt"` \
                || outputArgsList[$len]="    ~~ 空白 ~~"
        elif [ -n "$otherBySelfTxt" ]; then
            outputTemplate+="%s\n"
            outputArgsList[$len]=$otherBySelfTxt
        fi
    fi
    printf "$outputTemplate" "${outputArgsList[@]}"
}

showHelpRecord "main_info_platformCode" "平台代碼。"
# fnOpt_main_info_platformCode() { return }
fnSh_main_info_platformCode() {
    platformCode.sh "$@"
}

showHelpRecord "main_plant" "\
種植環境樹。
# 解析用戶設定並建立初始環境。 (原命令： \`spring\`)
[[USAGE]] <環境家目錄名稱>
[[SUBCMD]]
  build       [[BRIEFLY:build]]
  setBashrc   [[BRIEFLY:setBashrc]]
[[OPT]]
  -f, --force   強制性重新建立初始環境。
                (僅 \"/path/to/環境家目錄/capp/bin/\" 會被強制重建，
                 其他如 \"/path/to/環境家目錄/\" 則優先採用原始文件。)
  -h, --help    幫助。
"
fnOpt_main_plant() {
    case "$1" in
        -f | --force )
            opt_force=1
            parseOption_shift=1
            ;;
        -h | --help ) showHelp "$_fileName" ;;
        * ) parseOption_shift=3 ;;
    esac
}
fnSh_main_plant() {
    opt_force=0
    parseOption "$_fileName"

    fnParseProFileConfig_checkConfigPath "$configPath"

    local envHomeDirNameArgu=${_args[0]}

    if [ -z "$envHomeDirNameArgu" ]; then
        loxog -f "$_fileName" err "未提供環境家目錄名稱。"
        exit
    fi

    local envHomeDirName="${envHomeDirNameArgu}Home"
    fnPlantEnvHome "$ysPath_envfile/$envHomeDirName"
    fnEnvHomeInit

    local configMd5Path="$plantHome_capp/$ysBashConfigFileName.md5"
    if [ $opt_force -eq 0 ] && md5sum -c "$configMd5Path" &> /dev/null ; then
        loxog -f "$_fileName" war \
            "環境樹初始環境已被建立，可使用 \`-f, --force\` 選項重新建立。"
        exit
    fi

    md5sum "$configPath" > "$configMd5Path"

    fnBuildBaseFile
    local binLinkCommandTxt="$rtnBuildBaseFile_binLinkCommandTxt"
    local buildCommandTxt="$rtnBuildBaseFile_buildCommandTxt"
    local bashrcCommandTxt="$rtnBuildBaseFile_bashrcCommandTxt"
    local completercCommandTxt="$rtnBuildBaseFile_completercCommandTxt"

    # ln -sf path/to/module/bin & `LINK` 命令設定'
    if [ -d "$plantHome_cappBin" ]; then
        rm -rf "$plantHome_cappBin"/*
    else
        mkdir -p "$plantHome_cappBin"
    fi
    sh -c "`grep "\S" <<< "$binLinkCommandTxt"`"
    # ysBash.build
    echo "$buildCommandTxt" > "$plantHome_capp/$ysBashBuildFileName"
    # ysBash.bashrc
    echo "$bashrcCommandTxt" > "$plantHome_capp/$ysBashBashrcFileName"
    # ysBash.completerc
    echo "$completercCommandTxt" > "$plantHome_capp/$ysBashCompletercFileName"

    fnSetBashrc
}

showHelpRecord "main_plant_build" "\
執行環境建立文件。
[[USAGE]]
[[OPT]]
  -c, --cat                        顯示文件內容對應的行數。
  -l, --onlyLine <n1[,nN ...]>     僅執行指定行數的文件內容。
  -n, --ignoreLine <n1[,nN ...]>   僅執行指定行數以外的文件內容。
  -h, --help                       幫助。
"
fnOpt_main_plant_build() {
    case "$1" in
        -c | --cat )
            opt_cat=1
            parseOption_shift=1
            ;;
        -l | --onlyLine )
            [ -z "`grep "^\([0-9]\+,\)*[0-9]\+$" <<< "$2"`" ] && parseOption_shift=4

            opt_onlyLine=$2
            parseOption_shift=2
            ;;
        -n | --ignoreLine )
            [ -z "`grep "^\([0-9]\+,\)*[0-9]\+$" <<< "$2"`" ] && parseOption_shift=4

            opt_ignoreLine=$2
            parseOption_shift=2
            ;;
        -h | --help ) showHelp "$_fileName" ;;
        * ) parseOption_shift=3 ;;
    esac
}
fnSh_main_plant_build() {
    opt_cat=0
    opt_onlyLine=""
    opt_ignoreLine=""
    parseOption "$_fileName"

    local errMsg_runCmd
    local ysBashBuildPath="$homeCapp/$ysBashBuildFileName"
    if [ -z "$__plantHomePath" ]; then
        [ ! -f "$ysBashBuildPath" ] \
            && errMsg_runCmd="$_fileName which <環境家目錄名稱> && source $HOME/.bashrc" \
            || errMsg_runCmd="source $HOME/.bashrc"
        loxog -f "$_fileName" war "未處於環境樹環境中，可執行 \`$errMsg_runCmd\` 命令切換。"
        exit
    fi
    if [ ! -f "$ysBashBuildPath" ]; then
        loxog -f "$_fileName" err "環境建立文件 \"$ysBashBuildPath\" 不存在。"
        exit
    fi

    if [ $opt_cat -eq 1 ]; then
        cat -n "$ysBashBuildPath" | grep "^\s\+[0-9]\+\s." | grep -v "^\s\+[0-9]\+\s#"
        # grep -n "." "$configPath" | grep -v "^#"
        return
    fi

    local idx lastIdx
    local onlyLine=""
    if [ -n "$opt_onlyLine" ]; then
        onlyLine=$opt_onlyLine
    elif [ -n "$opt_ignoreLine" ]; then
        lastIdx=`wc -l "$ysBashBuildPath" | cut -d " " -f 1`
        for ((idx=0; idx <= lastIdx ; idx++))
        do
            [ -z "`grep -Fo ",$idx," <<< ",$opt_ignoreLine,"`" ] || continue
            onlyLine+="$idx,"
        done
    fi

    "$_dirsh/ysBash_build" "$_fileName" \
        "$homeYs" "$__plantHomePath" \
        "$cmdPlatformCode" "$ysBashBuildPath" "$onlyLine"
}

showHelpRecord "main_plant_setBashrc" "\
設定 .bashrc 文件與環境的連結。
[[USAGE]]
[[OPT]]
  -h, --help   幫助。
"
fnOpt_main_plant_setBashrc() {
    case "$1" in
        -h | --help ) showHelp "$_fileName" ;;
        * ) parseOption_shift=3 ;;
    esac
}
fnSh_main_plant_setBashrc() {
    parseOption "$_fileName"
    fnSetBashrc
}

showHelpRecord "main_which" "\
在本地家目錄引入環境家目錄的連結。
[[USAGE]] <環境家目錄名稱>
[[OPT]]
  -h, --help                       幫助。
"
fnOpt_main_which() {
    case "$1" in
        -h | --help ) showHelp "$_fileName" ;;
        * ) parseOption_shift=3 ;;
    esac
}
fnSh_main_which() {
    parseOption "$_fileName"

    local envHomeDirNameArgu=${_args[0]}

    local envHomeDirName="${envHomeDirNameArgu}Home"
    fnPlantEnvHome "$ysPath_envfile/$envHomeDirName"

    if [ -z "$envHomeDirNameArgu" ]; then
        loxog -f "$_fileName" err "未提供環境家目錄名稱。"
        exit
    fi
    if [ ! -d "$plantHome" ]; then
        loxog -f "$_fileName" err "環境家目錄不存在。"
        exit
    fi

    local sourcePath targetPath fileName

    # 檢查
    local ynHasError=0
    while read sourcePath
    do
        fileName=`basename "$sourcePath"`
        [ "$fileName" != "ys" ] || continue

        targetPath="$HOME/$fileName"
        [ -e "$targetPath" ] || continue
        [ ! -L "$targetPath" ] || [[ ! "`readlink "$targetPath"`" =~ ^\.\/ys\/ ]] ||
            continue

        ynHasError=1
        echo "路徑 \"$targetPath\" 已存在。" | loxog -f "$_fileName" war
    done <<< `find "$plantHome" -maxdepth 1 | sed "1d"`
    [ $ynHasError -eq 0 ] || exit

    # 移除
    find "$HOME" -maxdepth 1 | sed "1d" | while read targetPath
    do
        fileName=`basename "$targetPath"`
        [ "$fileName" != "ys" ] || continue

        ([ -e "$plantHome/$fileName" ] ||
            ([ -L "$targetPath" ] && [[ "`readlink "$targetPath"`" =~ ^\.\/ys\/ ]])) \
            && rm -rf "$targetPath" || :
    done

    # 引入
    find "$plantHome" -maxdepth 1 | sed "1d" | while read sourcePath
    do
        fileName=`basename "$sourcePath"`
        ([ "$fileName" != "ys" ] && [ "$fileName" != ".ys" ]) || continue

        targetPath="$HOME/$fileName"
        ln -s "./ys/${sourcePath:$((${#ysPath} + 1))}" "$targetPath"
    done
}

showHelpRecord "main_edit" "\
編輯相關文件。
# config： 設定文件
[[USAGE]] [文件 ... (config)]
[[OPT]]
  -h, --help   幫助。
"
fnOpt_main_edit() {
    case "$1" in
        -h | --help ) showHelp "$_fileName" ;;
        * ) parseOption_shift=3 ;;
    esac
}
fnSh_main_edit() {
    parseOption "$_fileName"

    local item openNameList filePath templateFilePath
    local isNotFined=0
    local openFileList=()

    if [ ${#_args[@]} -eq 0 ]; then
        openNameList=(config)
    else
        openNameList=("${_args[@]}")
    fi

    for item in "${openNameList[@]}"
    do
        case $item in
            config )
                templateFilePath="$_dirsh/_${configFileName}.template"
                filePath=$configPath
                [ ! -f "$filePath" ] && cp "$templateFilePath" "$filePath"
                openFileList[${#openFileList[@]}]=$filePath
                ;;
            * )
                isNotFined=1
                loxog -f "$_fileName" --stderr err "找不到 \"$item\" 文件。"
                ;;
        esac
    done

    [ $isNotFined -eq 1 ] && exit 1

    vim "${openFileList[@]}"
}

showHelpRecord "main_createModule" "\
創建模組資料夾。
[[USAGE]] <模組名稱>
[[OPT]]
  -h, --help   幫助。
"
fnOpt_main_createModule() {
    case "$1" in
        -h | --help ) showHelp "$_fileName" ;;
        * ) parseOption_shift=3 ;;
    esac
}
fnSh_main_createModule() {
    parseOption "$_fileName"

    local moduleName="$1"

    [ -z "$moduleName" ] && showHelp "$_fileName"

    local moduleDirname="$ysPath_libCapp/$moduleName"

    [ -e "$moduleDirname" ] \
        && loxog -f "$_fileName" war \
            "目標位置 \"$moduleDirname\" 已存在目錄或文件。" \
        && exit

    fnTmpCreateModuleBashSample() {
        local execSymbol="$1"
        local dirName="$2"
        local prefix="$3"
        local extName="$4"

        local fileRelativePath="$dirName/`
            [ -n "$prefix" ] && echo "$prefix-"
        `$moduleName`
            [ -n "$extName" ] && echo "$extName" || echo ".sh"
        `"
        local fileName="$moduleDirname/$fileRelativePath"

        printf \
            "#!/bin/bash\n# $fileRelativePath\necho \"I'm $fileRelativePath\"\n" \
            > "$fileName"

        [ ! "$execSymbol" == "*" ] || chmod 755 "$fileName"
    }

    mkdir -p \
        "$moduleDirname/bin" \
        "$moduleDirname/lib" \
        "$moduleDirname/ysBashBuild" \
        "$moduleDirname/bashrcSource" \
        "$moduleDirname/bashrcSh"

    fnTmpCreateModuleBashSample "*" "lib"
    fnTmpCreateModuleBashSample " " "lib" "" ".completion.cmdEnum"
    ln -s "../lib/$moduleName.sh" "$moduleDirname/bin"
    ln -s "../lib/$moduleName.completion.cmdEnum" \
        "$moduleDirname/bashrcSource/completion-$moduleName.cmdEnum"
    fnTmpCreateModuleBashSample "*" "bashrcSh"
    fnTmpCreateModuleBashSample "*" "ysBashBuild" "env"
    fnTmpCreateModuleBashSample "*" "ysBashBuild" "install"
    fnTmpCreateModuleBashSample "*" "bashrcSource" "completion"
    fnTmpCreateModuleBashSample "*" "bashrcSource"
}


##shStyle 共享變數


# Ys 目錄路徑
ysPath=`realpath "$_dirsh/../../.."`
ysPath_libCapp="$ysPath/lib.capp"
ysPath_envfile="$ysPath/envfile"
ysPath_envfileSharehome="$ysPath/envfile/sharehome"

allowAllPlatformCode=`platformCode.sh allowAll`
cmdPlatformCode=`platformCode.sh`

ysBashCompleteShPath="$_dirsh/ysBashComplete"
configFileName="envtree.config"
ysBashConfigFileName="ysBash.$configFileName"
configPath="$ysPath_envfile/$ysBashConfigFileName"

ysBashBuildFileName="ysBash.build"
ysBashBashrcFileName="ysBash.bashrc"
ysBashCompletercFileName="ysBash.completerc"

# 由 main_plant 的相關命令設置
# 欲修改路徑名稱見 `fnPlantEnvHome` 方法
plantHome=""
# plantHome_ys=""
plantHome__ys=""
plantHome_capp=""
plantHome_cappBin=""
plantHomeDynamicPath=""

homeYs="$HOME/ys"
homeCapp="$HOME/capp"
homeYsTxt="\$HOME/ys"
homeCappTxt="\$HOME/capp"


##shStyle 函式庫


fnYsDynamicPath() {
    local path="$1"
    echo "$homeYsTxt/${path:$((${#ysPath} + 1))}"
}

fnPlantEnvHome() {
    local envHomePath="$1"

    plantHome="$envHomePath"
    # plantHome_ys="$envHomePath/ys"
    plantHome__ys="$envHomePath/.ys"
    plantHome_capp="$envHomePath/capp"
    plantHome_cappBin="$envHomePath/capp/bin"
    [ "$plantHome" == "/tmp/ysBash_plantHomePath" ] \
        && plantHomeDynamicPath="/tmp/ysBash_plantHomePath" \
        || plantHomeDynamicPath=`fnYsDynamicPath "$plantHome"`
}

rtnParseProFileConfig_commandTxt=""
rtnParseProFileConfig_otherBySelfTxt=""
fnParseProFileConfig() {
    local configPath="$1"

    fnParseProFileConfig_checkConfigPath "$configPath"

    local tmp idx len
    local line arguName setVal
    local configTxt=`cat "$configPath"`
    local commandTxt=""
    local otherBySelfTxt=""

    local rtnTmpCutList=()
    fnTmpCutList() {
        rtnTmpCutList=("$@")
    }

    for line in "HOME \$HOME" "ysPath $homeYsTxt" "plantHome $plantHomeDynamicPath"
    do
        fnTmpCutList $line
        arguName=${rtnTmpCutList[0]}
        setVal=`sed 's/\([&\/]\)/\\\\\1/g' <<< "${rtnTmpCutList[@]:1}"`
        configTxt=`sed "s/\[\[$arguName\]\]/$setVal/g" <<< "$configTxt"`
    done

    while read line
    do
        fnTmpCutList $line
        arguName=${rtnTmpCutList[2]}

        setVal=`sed 's/\([&\/]\)/\\\\\1/g' <<< "${rtnTmpCutList[@]:3}"`

        configTxt=`sed "s/\[\[$arguName\]\]/$setVal/g" <<< "$configTxt"`
        break
    done <<< "`grep "# var [A-Za-z0-9_-]\+ .*" <<< "$configTxt" | sed "s/ ----*= / /g"`"

    len=`wc -l <<< "$configTxt"`
    idx=`grep -n "" <<< "$configTxt" \
        | grep -m 1 "\([0-9]*\):## OTHER BySelf ##" \
        | cut -d ":" -f 1`
    commandTxt=`head -n $(($idx - 1)) <<< "$configTxt" \
        | sed "s/#.*//g" | grep -v "^\s*$" \
        | sed "s/ ----*= / /g" | sed "s/ =----*= //g"`
    otherBySelfTxt=`tail -n $(($len - $idx)) <<< "$configTxt" \
        | sed "s/#.*//g" | grep -v "^\s*$"`

    fnParseProFileConfig_checkCommandError "$commandTxt" "$otherBySelfTxt"

    rtnParseProFileConfig_commandTxt=$commandTxt
    rtnParseProFileConfig_otherBySelfTxt=$otherBySelfTxt
}
fnParseProFileConfig_checkConfigPath() {
    local configPath="$1"

    if [ ! -f "$configPath" ]; then
        loxog -f "$_fileName" --stderr war \
            "找不到 \"$configPath\" 文件。" \
            "可執行 \`$_fileName edit config\` 創建編輯。"
        exit 1
    fi
}
fnParseProFileConfig_checkCommandError() {
    local commandTxt="$1"
    local otherBySelfTxt="$2"

    local txt
    local errMsgTitle="解析設定文件錯誤，請使用 \`$_fileName edit config\` 修改。"
    local isThrow=0

    if [ -n "`grep -v "^[0-9]\+ \(IMPORT\|LINK\|PATH\|SRCMD\) " <<< "$commandTxt"`" ];
    then
        isThrow=1
        echo "$errMsgTitle" | loxog -f "$_fileName" --stderr err
        grep -v "^[0-9]\+ \(IMPORT\|LINK\|PATH\|SRCMD\) " <<< "$commandTxt" \
            | sed "s/^\(.\+\)/    無法解析： \1/" \
            | loxog -f "$_fileName" --stderr err "  * 命令解析錯誤："
    fi

    txt=`sh -c "$otherBySelfTxt" 2>&1 1> /dev/null`
    if [ $? -ne 0 ]; then
        [ $isThrow -eq 0 ] && echo "$errMsgTitle" | loxog -f "$_fileName" --stderr war
        echo "$txt" | sed "s/^\(.\+\)/    \1/" \
            | loxog -f "$_fileName" --stderr war \
                "  * 關於 \"OTHER BySelf\" 命令解析警告："
    fi

    [ $isThrow -eq 0 ] || exit 1
}
fnParseProFileConfig_filterEnvCode() {
    local _stdin=`[ ! -t 0 ] && { \
        IFS='';
        while read pipeData; do echo "$pipeData"; done <&0;
        unset IFS
    }`

    local envCode="$1"

    local line
    local outTxt=""

    while read line
    do
        [ $[`grep -o "^[0-9]\+" <<< "$line"` & $envCode] -ne 0 ] \
            && outTxt+="$line$_br"
    done <<< "$_stdin"

    printf "$outTxt"
}
fnParseProFileConfig_sortTxt() {
    local _stdin=`[ ! -t 0 ] && { \
        IFS='';
        while read pipeData; do echo "$pipeData"; done <&0;
        unset IFS
    }`

    local args=("$@")

    local txt key
    local commandTxt=$_stdin
    local sortTxt=""

    for key in "${args[@]}"
    do
        txt=`grep "^[0-9]\+ $key " <<< "$commandTxt"`
        [ -n "$txt" ] && sortTxt+="$txt$_br"
    done

    printf "$sortTxt"
}
fnParseProFileConfig_handle() {
    local _stdin=`[ ! -t 0 ] && { \
        IFS='';
        while read pipeData; do echo "$pipeData"; done <&0;
        unset IFS
    }`

    local method

    local rtnTmpCutList=()
    fnTmpCutList() {
        rtnTmpCutList=("$@")
    }

    local line

    while read line
    do
        fnTmpCutList $line
        method=${rtnTmpCutList[1]}

        case "$method" in
            IMPORT )
                fnParseProFileConfig_handle_import \
                    "$ysPath_libCapp/${rtnTmpCutList[2]}"
                ;;
            LINK )
                fnParseProFileConfig_handle_link \
                    "${rtnTmpCutList[*]:3}" \
                    "$plantHome_cappBin/${rtnTmpCutList[2]}"
                ;;
            PATH )
                fnParseProFileConfig_handle_path \
                    "`echo "${rtnTmpCutList[*]:2}" | sed 's/\/\/*/\//g'`"
                ;;
            SRCMD )
                fnParseProFileConfig_handle_srcmd "${rtnTmpCutList[*]:2}"
                ;;
        esac
    done <<< "$_stdin"
}
fnParseProFileConfig_handle_import() { return; }
fnParseProFileConfig_handle_link()   { return; }
fnParseProFileConfig_handle_path()   { return; }
fnParseProFileConfig_handle_srcmd()  { return; }

rtnPlantHomeLnkPath=""
fnPlantHomeLnkPathRelative() {
    local referencePath="$1"   # 參考位置絕對在 $ysPath 內
    local queryPath="$2"

    local execFilePath
    local ysDirPathLength=$((${#ysPath} + 1))

    if [ "${queryPath::$ysDirPathLength}" == "${ysPath}/" ]; then
        fnPlantHomeLnkPathRelative_pathRelativeSelf "$referencePath" "$plantHome__ys"
        plantHomeYsRelativePath="$fnfnPlantHomeLnkPath_rtnPathRelativeSelf"
        execFilePath="$plantHomeYsRelativePath/${queryPath:$ysDirPathLength}"
    else
        execFilePath="$queryPath"
    fi

    rtnPlantHomeLnkPath=$execFilePath
}
fnPlantHomeLnkPathRelative_rtnPathRelativeSelf=""
fnPlantHomeLnkPathRelative_pathRelativeSelf() {
    local referencePath="$1"
    local queryPath="$2"

    local execFilePath

    fnPathRelative "$referencePath" "$queryPath" &> /dev/null
    if [ $? -eq 0 ]; then
        execFilePath=`fnPathRelative "$referencePath" "$queryPath"`
    else
        execFilePath="$queryPath"
    fi

    fnfnPlantHomeLnkPath_rtnPathRelativeSelf=$execFilePath
}

fnEnvHomeInit() {
    [ -d "$plantHome"         ] || mkdir "$plantHome"
    [ -d "$plantHome_capp"    ] || mkdir "$plantHome_capp"

    [ ! -d "$plantHome_cappBin" ] || rm -rf "$plantHome_cappBin"
    mkdir "$plantHome_cappBin"

    local sourcePath targetPath fileName
    if [ -d "$ysPath_envfileSharehome" ]; then
        find "$ysPath_envfileSharehome" -maxdepth 1 | sed "1d" | while read sourcePath
        do
            fileName=`basename "$sourcePath"`
            targetPath="$plantHome/$fileName"
            [ ! -e "$targetPath" ] || continue
            # 無視共享家目錄中的 "ys" 文件或目錄
            [ ! "$fileName" == "ys" ] || continue

            if [ "$fileName" == ".ys" ] ||
               ([ -L "$sourcePath" ] && [[ "`readlink "$sourcePath"`" =~ ^\.\/ys\/ ]]);
            then
                # 複製連結需使用 `-rf`
                cp -rf "$sourcePath" "$targetPath"
            else
                fnPlantHomeLnkPathRelative "$plantHome" "$sourcePath"
                ln -sf "$rtnPlantHomeLnkPath" "$targetPath"
            fi
        done
    fi
}

rtnBuildBaseFile_binLinkCommandTxt=""
rtnBuildBaseFile_buildCommandTxt=""
rtnBuildBaseFile_bashrcCommandTxt=""
rtnBuildBaseFile_completercCommandTxt=""
fnBuildBaseFile() {
    # global: configPath, ysBashCompleteShPath, fnParseProFileConfig
    # plantHome, plantHome__ys, plantHome_cappBin

    local txt
    local commandTxt otherBySelfTxt
    local handle_import_binRunLsTxt=""
    local handle_import_ysBashBuildEnvLsTxt=""
    local handle_import_ysBashBuildInstallLsTxt=""
    local handle_import_bashrcCompletionLsTxt=""
    local handle_import_bashrcCmdEnumCompletionLsTxt=""
    local handle_import_bashrcSourceLsTxt=""
    local handle_import_bashrcShLsTxt=""
    local handle_link_commandTxt=""
    local handle_path_commandTxt=""
    local handle_srcmd_commandTxt=""
    local binLinkCommandTxt=""
    local buildCommandTxt=""
    local bashrcCommandTxt=""
    local completercCommandTxt=""

    fnParseProFileConfig "$configPath"
    commandTxt="$rtnParseProFileConfig_commandTxt"
    otherBySelfTxt="$rtnParseProFileConfig_otherBySelfTxt"

    fnParseProFileConfig_handle_import() {
        local moduleDirPath="$1"

        if [ ! -d "$moduleDirPath" ]; then
            # 此處的標準輸入中仍有 `fnParseProFileConfig_handle` 未處理完的值
            # 所以只能使用 `echo ... | loxog` 覆蓋 loxog 的接收值
            echo "忽略不存在的 \"$moduleDirPath\" 模組目錄名。" \
                | loxog -f "$_fileName" --stderr war
            return
        fi

        local txt supDirName dirPath line lsTxt lsTxtDynamicPath

        for supDirName in bin ysBashBuild bashrcSource bashrcSh
        do
            dirPath="$moduleDirPath/$supDirName"
            [ ! -d "$dirPath" ] && continue

            while read line
            do
                lsTxt="$dirPath/$line"
                [ ! -d "$lsTxt" ] || continue

                lsTxtDynamicPath=`fnYsDynamicPath "$lsTxt"`

                case "$supDirName/$line" in
                    bin/* )
                        fnPlantHomeLnkPathRelative "$plantHome_cappBin" "$lsTxt"
                        txt="ln -sf \"$rtnPlantHomeLnkPath\" \"$plantHome_cappBin\""
                        handle_import_binRunLsTxt+=$txt$_br
                        ;;
                    ysBashBuild/env-* )
                        handle_import_ysBashBuildEnvLsTxt+=$lsTxtDynamicPath$_br
                        ;;
                    ysBashBuild/install-* )
                        handle_import_ysBashBuildInstallLsTxt+=$lsTxtDynamicPath$_br
                        ;;
                    bashrcSource/completion-*.cmdEnum )
                        txt="__ysBashComplete_register \"$lsTxtDynamicPath\""
                        handle_import_bashrcCmdEnumCompletionLsTxt+=$txt$_br
                        ;;
                    bashrcSource/completion-* )
                        txt="source \"$lsTxtDynamicPath\""
                        handle_import_bashrcCompletionLsTxt+=$txt$_br
                        ;;
                    bashrcSource/* )
                        txt="source \"$lsTxtDynamicPath\""
                        handle_import_bashrcSourceLsTxt+=$txt$_br
                        ;;
                    bashrcSh/* )
                        txt="sh \"$lsTxtDynamicPath\""
                        txt+=" \"\$__ysBashPath\" \"\$__plantHomePath\" \"\$__envCode\""
                        handle_import_bashrcShLsTxt+=$txt$_br
                        ;;
                esac
            done <<< "`ls -A "$dirPath"`"
        done
    }
    fnParseProFileConfig_handle_link() {
        local execFilePathArge="$1"
        local linkPath="$2"

        fnPlantHomeLnkPathRelative "$plantHome_cappBin" "$execFilePathArge"
        local execFilePath="$rtnPlantHomeLnkPath"

        handle_link_commandTxt+="ln -sf \"$execFilePath\" \"$linkPath\"$_br"
    }
    fnParseProFileConfig_handle_path() {
        local binDirPath="$1"
        handle_path_commandTxt+='    "'$binDirPath'"'$_br
    }
    fnParseProFileConfig_handle_srcmd() {
        local commandTxt="$1"

        handle_srcmd_commandTxt+=$commandTxt$_br
    }

    fnParseProFileConfig_handle <<< `echo "$commandTxt" \
        | fnParseProFileConfig_filterEnvCode $cmdPlatformCode \
        | fnParseProFileConfig_sortTxt "IMPORT" "LINK" "PATH" "SRCMD"`

    # 不是私有函式
    fnParseProFileConfig_handle_import() { return; }
    fnParseProFileConfig_handle_link()   { return; }
    fnParseProFileConfig_handle_path()   { return; }
    fnParseProFileConfig_handle_srcmd()  { return; }

    # ln -sf path/to/module/bin & `LINK` 命令設定'
    txt=$handle_import_binRunLsTxt
    txt+=$handle_link_commandTxt
    binLinkCommandTxt=`grep "\S" <<< "$txt"`

    # ysBash.build
    txt="# IMPORT env"$_br$handle_import_ysBashBuildEnvLsTxt$_br
    txt+="# IMPORT install"$_br$handle_import_ysBashBuildInstallLsTxt$_br
    buildCommandTxt=`grep "\S" <<< "$txt"`

    # ysBash.bashrc
    bashrcCommandTxt="#!/bin/bash$_br"
    bashrcCommandTxt+="# Base Info$_br"
    bashrcCommandTxt+="export __ysBashPath=\"$homeYsTxt\"$_br"
    bashrcCommandTxt+="export __plantHomePath=\"$plantHomeDynamicPath\"$_br"
    bashrcCommandTxt+="export __envCode=\"$cmdPlatformCode\"$_br"
    bashrcCommandTxt+="# PATH$_br"
    bashrcCommandTxt+="tmpPathList=($_br$handle_path_commandTxt$_br)$_br"
    bashrcCommandTxt+="for tmpPath in \"\${tmpPathList[@]}\"$_br"
    bashrcCommandTxt+="do [[ \":\$PATH:\" =~ \":\$tmpPath:\" ]] || PATH=\"\$PATH:\$tmpPath\"; done$_br"
    bashrcCommandTxt+="unset tmpPath tmpPathList$_br"
    bashrcCommandTxt+="# IMPORT source$_br$handle_import_bashrcSourceLsTxt"
    bashrcCommandTxt+="# IMPORT sh$_br$handle_import_bashrcShLsTxt"
    bashrcCommandTxt+="# SRCMD$_br$handle_srcmd_commandTxt$_br"
    bashrcCommandTxt+="# OTHER BySelf$_br$otherBySelfTxt$_br"
    bashrcCommandTxt=`grep "\S" <<< "$bashrcCommandTxt"`

    # ysBash.completerc
    completercCommandTxt="#!/bin/bash$_br"
    completercCommandTxt+="# IMPORT completion$_br"
    txt=$handle_import_bashrcCompletionLsTxt$handle_import_bashrcCmdEnumCompletionLsTxt
    [ -n "$txt" ] &&
        completercCommandTxt+="source \"`fnYsDynamicPath "$ysBashCompleteShPath"`\"$_br"
    completercCommandTxt+=$handle_import_bashrcCompletionLsTxt
    completercCommandTxt+=$handle_import_bashrcCmdEnumCompletionLsTxt
    completercCommandTxt=`grep "\S" <<< "$completercCommandTxt"`

    rtnBuildBaseFile_binLinkCommandTxt=$binLinkCommandTxt
    rtnBuildBaseFile_buildCommandTxt=$buildCommandTxt
    rtnBuildBaseFile_bashrcCommandTxt=$bashrcCommandTxt
    rtnBuildBaseFile_completercCommandTxt=$completercCommandTxt
}

# .bashrc 設定
fnSetBashrc() {
    local bashrcPath="$plantHome/.bashrc"

    [ -f "$bashrcPath" ] || echo -e "# ~/.bashrc" > "$bashrcPath"

    [ -n "`grep "## Ys Bash ##" "$bashrcPath"`" ] ||
        ( echo -e "\n\n\n## Ys Bash ##\n\n"
          printf "source %s\n" \
              "$homeCappTxt/$ysBashBashrcFileName" \
              "$homeCappTxt/$ysBashCompletercFileName"
          echo
        ) >> "$bashrcPath"

    loxog -f "$_fileName" war "請執行 \`source $bashrcPath\`"
}


##shStyle ###


# 設定 "/tmp" 的目的是不想因為失誤而污染環境
fnPlantEnvHome "/tmp/ysBash_plantHomePath"

shScript "main" "$@"

