#!/bin/bash
# 命令環境


##shStyle ###


_originPlace="lib"

_shScript() {
    ysPath=`realpath "$_binsh/../.."`
    ysCappPath=$ysPath/capp
    ysUserdirPath=$ysPath/_userdir

    cmdPlatformCode=`fnPlatformCode "get"`

    configPath=$_dirsh/bashrc.config
    proFilePath=$HOME/.bashrc.ysBash

    proFileTxt="#!/bin/bash"$_br


    case "$1" in
    init ) _shCmdLevel=1 ;;
    note ) _shCmdLevel=1 ;;
    esac
}


##shStyle 介面函式


fnHelp_main() { echo "# 環境樹設置
[[USAGE]]
[[SUBCMD]]
  init    $fnHelp_init_briefly
  note    $fnHelp_note_briefly
[[OPT]]
  -h, --help                 幫助。
"; }
fnOpt_main() {
    case "$1" in
        -h | --help ) fnShowHelp ;;
        * ) return 3 ;;
    esac
}
fnMain() {
    fnShowHelp
}

fnHelp_init_briefly="初始化環境樹。"
fnHelp_init() { echo "# $fnHelp_init_briefly
[[USAGE]]
[[OPT]]
      --update   更新。
  -h, --help     幫助。
"; }
fnOpt_init() {
    case "$1" in
        --update )
            opt_update=1
            return 1
            ;;
        -h | --help ) fnShowHelp ;;
        * ) return 3 ;;
    esac
}
fnMain_init() {
    opt_update=0
    fnParseOption

    if [ $opt_update -eq 0 ] && [ -f "$proFilePath" ]; then
        Loxog war \
            "環境樹未被更新，請使用 \`--update\` 選項進行更新。" \
            "或執行 \`source $HOME/.bashrc\`"
        exit
    fi


    fnBashCompletion
    fnParseProFileConfig

    # 安裝預設應用程式
    _eval() { source "$_dirsh/ysBash_installDefaultApp"; }; _eval
    fnLinkDefault

    proFileTxt+=$_br$_br$_br$_dirsh/ysBash_note$_br
    echo "$proFileTxt" > "$proFilePath"
    fnSetBashrc
}

fnHelp_note_briefly="顯示記事字條。"
fnHelp_note() { echo "# $fnHelp_note_briefly
# 字條路徑為 \"$ysPath/notepad.txt\"
[[USAGE]]
[[OPT]]
  -h, --help                 幫助。
"; }
fnOpt_note() {
    case "$1" in
        -h | --help ) fnShowHelp ;;
        * ) return 3 ;;
    esac
}
fnMain_note() {
    fnParseOption

    local line
    local notePath=$ysPath/notepad.txt

    # 時間戳 timestamp
    echo `date +"%Y-%m-%d %H:%M:%S [%A] +%s%3N"`

    fnPrintRandomColor() {
        local prefix="$1"
        local txt="$2"

        [ -z "$txt" ] && return

        local color=`_fColor $(( $RANDOM % 6 + 1 )) 1`

        printf "  $prefix $color%s$_fN\n" "$txt"
    }

    # 字條
    [ -z "`cat "$notePath"`" ] && fnPrintRandomColor x "無字條被留下" && return
    while read line
    do
        [ -n "$line" ] && fnPrintRandomColor - "$line"
    done < $notePath
}


##shStyle 共享變數



##shStyle 函式庫


rtnLsList=()
fnLsList() {
    local txt len idx val
    local lsOpt="$1"
    [ "${lsOpt:0:1}" == "-" ] && shift || lsOpt=""

    local list path
    list=()

    for path in "$@"
    do
        txt=`ls $lsOpt -1 $path 2> /dev/null`
        [ $? -ne 0 ] && continue

        len=`ls $lsOpt -1 $path | wc -l`
        [ $len -eq 0 ] && continue

        for idx in `seq 1 $len`
        do
            val=`echo "$txt" | sed -n "${idx}p"`
            list[ ${#list[@]} ]=$val
        done
    done

    rtnLsList=("${list[@]}")
}

fnPlatformCode() {
    local method="$1"
    local platformCode=$2

    case "$method" in
        get )
            case `uname` in
                *CYGWIN* ) echo 2 ;; # Cygwin
                * )        echo 1 ;; # Linux
            esac
            ;;
        parse )
            case $platformCode in
                3  ) echo "1 2" ;;
                *  ) echo $platformCode ;;
            esac
            ;;
    esac
}

fnLinkFile() {
    local filePath="$1"
    local linkPath="$2"

    local tmp regex fileInfo
    regex="s/\([0-9.]\+\w\) \(.\+\)/\2 (\1)/"

    if [ ! -e "$linkPath" ]; then
        ln -s "$filePath" "$linkPath"
    else
        if [ -L "$linkPath" ]; then
            fileInfo="$linkPath (鏈結文件)"
            [ "`realpath "$linkPath"`" == "`realpath "$filePath"`" ] && return
        elif [ -d "$linkPath" ]; then
            fileInfo="$linkPath (目錄)"
        else
            fileInfo=`ls -sh "$linkPath" | sed "$regex"`
        fi

        printf "文件已存在： %s\n" "$fileInfo"
        printf "是否覆蓋文件 ( Yes / No ) ： "
        read tmp
        case $tmp in
            [Yy] | "Yes" | "yes" )
                [ -d "$linkPath" ] && rm -rf "$linkPath" || rm "$linkPath"
                ln -s "$filePath" "$linkPath"
                ;;
        esac
    fi
}

# bash completion
fnBashCompletion() {
    local filename

    fnLsList "$HOME/ys/capp/bash_completion"
    for filename in "${rtnLsList[@]}"
    do
        proFileTxt+=$_br'source "'$ysCappPath/bash_completion/$filename'"'
    done
}

fnParseProFileConfig() {
    local txt idx len val

    local configTxt platformEnv method setVal
    local hisOtherBySelf=0

    local rtnCutList=()
    fnCutList() {
        rtnCutList=("$@")
    }

    configTxt=`cat "$configPath" | sed "s/#.*//g" | sed "s/^ *$//g" | grep "." | sed "s/ ----*= / /g"`

    txt=`cat "$configPath" | grep "# var .*" | sed "s/ ----*= / /g"`
    len=`echo -e "$txt" | wc -l`
    for idx in `seq 1 $len`
    do
        fnCutList `echo -e "$txt" | sed -n "${idx}p"`
        setVal=`echo "${rtnCutList[@]:3}" | sed 's/\([&\/]\)/\\\\\1/g'`
        configTxt=`echo "$configTxt" | sed "s/\[\[${rtnCutList[2]}\]\]/$setVal/g"`
    done

    len=`echo -e "$configTxt" | wc -l`
    for idx in `seq 1 $len`
    do
        val=`echo -e "$configTxt" | sed -n "${idx}p"`

        if [ $hisOtherBySelf -eq 1 ]; then
            proFileTxt+=$_br$val
        fi
        if [ "OTHER BySelf" == "$val" ]; then
            hisOtherBySelf=1
            proFileTxt+=$_br$_br$_br"## OTHER BySelf"$_br
        fi

        fnCutList $val

        platformEnv=`fnPlatformCode "parse" ${rtnCutList[0]}`
        method=${rtnCutList[1]}

        if [ -z "`echo " $platformEnv " | grep " $cmdPlatformCode "`" ]; then continue; fi

        case $method in
            SRCMD )
                proFileTxt+="$_br${rtnCutList[*]:2}"
                ;;
            LINK )
                fnLinkFile "${rtnCutList[*]:3}" "$_binsh/${rtnCutList[2]}"
                ;;
            PATH )
                setVal=`echo "$HOME/ys/${rtnCutList[*]:2}" | sed 's/\/\/*/\//g'`
                proFileTxt+=$_br
                proFileTxt+='[ -z "`echo ":$PATH:" | grep ":'$setVal':"`" ]'
                proFileTxt+=' && PATH="$PATH:'$setVal'"'
                ;;
            SOURCE )
                setVal=`echo "$HOME/ys/${rtnCutList[*]:2}" | sed 's/\/\/*/\//g'`
                proFileTxt+="$_br"'source "'$setVal'"'
                ;;
        esac
    done
}

# ys, .ys 目錄 及 鏈結文件
fnLinkDefault() {
    local val

    [ "$ysPath" != "$HOME/ys" ] && fnLinkFile "$ysPath" "$HOME/ys"
    fnLinkFile "$ysUserdirPath" "$HOME/.ys"
    fnLinkFile "$ysPath/capp"   "$HOME/capp"
    fnLinkFile "$ysPath/gitman" "$HOME/gitman"

    fnLsList -A "$ysUserdirPath"
    for val in "${rtnLsList[@]}"
    do
        fnLinkFile "$HOME/.ys/$val" "$HOME/$val"
    done
}

# .bashrc 設定
fnSetBashrc() {
    [ "$1" == "1" ] && hisAuto=1

    [ ! -f "$HOME/.bashrc" ] && echo -e "# ~/.bashrc" > "$HOME/.bashrc"

    [ -z "`grep "## 自訂 ##" "$HOME/.bashrc"`" ] \
        && echo -e "\n\n\n## 自訂 ##\n\nsource \$HOME/ys/.envtree.bash\n" >> "$HOME/.bashrc"

    Loxog war "請執行 \`source $HOME/.bashrc\`"
}


##shStyle 腳本環境


__filename=`realpath "$0"`
_dirsh=`dirname "$__filename"`
[ "$_originPlace" == "bin" ] && _binsh=$_dirsh || _binsh=`realpath "$_dirsh/../../bin"`
[ "$_originPlace" == "bin" ] && _libsh=`realpath "$_dirsh/../lib"` || _libsh=`realpath "$_dirsh/.."`
_fileName=`basename "$0"`

_PWD=$PWD
_br="
"

# 0 黑 black
# 1 紅 red
# 2 綠 green
# 3 黃 yellow
# 4 藍 blue
# 5 粉 magenta
# 6 青 cyan
# 7 白 white
_fColor() {
    local color=$1
    local bold=$2
    local bgcolor=$3
    local underline=$4

    [ $_fColor_usable -eq 0 ] && [ $_fColor_force -eq 0 ] && return

    if [ "$color" == "N" ]; then
        [ $_fColor_force -eq 0 ] \
            && printf "`tput sgr0`" \
            || printf "\e[00m"

        return
    fi

    case "$color" in
        [01234567] )
            [ $_fColor_force -eq 0 ] \
                && printf "`tput setaf $color`" \
                || printf "\e[3${color}m"
            ;;
    esac

    case "$bgcolor" in
        [01234567] )
            [ $_fColor_force -eq 0 ] \
                && printf "`tput setab $bgcolor`" \
                || printf "\e[4${bgcolor}m"
            ;;
    esac

    if [ "$bold" == "1" ]; then
        [ $_fColor_force -eq 0 ] \
            && printf "`tput bold`" \
            || printf "\e[01m"
    fi

    if [ "$underline" == "1" ]; then
        [ $_fColor_force -eq 0 ] \
            && printf "`tput smul`" \
            || printf "\e[04m"
    fi
}
_fColor_usable=0
_fColor_force=0

_fN=""
_fRedB=""
_fYelB=""

Loxog() {
    local _stdin=`[ ! -t 0 ] && { \
        IFS='';
        while read pipeData; do echo "$pipeData"; done <&0;
        unset IFS
    }`
    local method="$1"; shift

    local color formatArgus

    case $method in
        com ) color=$_fN    ;; # common
        war ) color=$_fYelB ;; # warn
        err ) color=$_fRedB ;; # error
    esac

    formatArgus="$color%s$_fN\n"

    local idx val len

    [ -n "$*" ] && printf "$formatArgus" "$@" 1>&2

    [ -z "$_stdin" ] && return
    len=`echo "$_stdin" | wc -l`
    for idx in `seq 1 $len`
    do
        val=`echo "$_stdin" | sed -n "${idx}p"`
        printf "$formatArgus" "$val" 1>&2
    done
}

_onCtrlC() {
    local val
    for val in "$@"
    do
        _onCtrlC_cmd+=$val$_br
    done
    trap 'sh -c "echo ; $_onCtrlC_cmd echo"; exit' 2
}
_onCtrlC_cmd=""


##shStyle ###


[ -L "$0" ] && exec "`realpath "$0"`" "$@"

_stdin=`[ ! -t 0 ] && while read pipeData; do echo $pipeData; done <&0`

_args=("$@")
_origArgs=("$@")

argsShift() {
    local amount=$1

    if [ -z "$amount" ] || [ $amount -lt 1 ]; then amount=1; fi
    _args=("${_args[@]:$amount}")
}

tmp=`tput colors`
[ -t 1 ] && [ -n "$tmp" ] && [ $tmp -ge 8 ] && _fColor_usable=1
_fnForceColor() {
    [ "$1" == 1 ] && _fColor_force=1
    _fN=`_fColor N`
    _fRedB=`_fColor 1 1`
    _fYelB=`_fColor 3 1`
}
_fnForceColor

fnParseOption() {
    local fnHandleOpt="fnOpt_$_shCmd"

    local tmp args opt val cutLen errMsg
    args=("${_args[@]}")
    errMsg=""

    while [ 1 ]
    do
        opt=${args[0]}
        val=${args[1]}
        cutLen=2

        if [ "$opt" == "--" ] || [ -z "`echo "_$opt" | grep "^_-"`" ]; then break; fi

        if [ -n "`echo "_$opt" | grep "^_-[^-]"`" ] && [ ${#opt} -ne 2 ]; then
            tmp="-"${opt:2}
            opt=${opt:0:2}
            val=""
            cutLen=1
            args=("$opt" "$tmp" "${args[@]:1}")
        elif [ -n "`echo "_$val" | grep "^_-"`" ]; then
            val=""
            cutLen=1
        fi

        if [ "$opt" == "--color" ]; then
            _fnForceColor 1
            tmp=1
        else
            $fnHandleOpt "$opt" "$val"
            tmp=$?
        fi
        case $tmp in
            0 )
                echo '請檢查 "'$fnHandleOpt'" 的錯誤回傳值。' 1>&2
                exit
                ;;
            # 使用 1 個參數
            1 )
                [ $cutLen -eq 2 ] && (( cutLen-- ))
                ;;
            # 使用 2 個參數
            2 ) ;;
            3 )
                errMsg+=$_br'找不到 "'$opt'" 選項。'
                ;;
            4 )
                [ "$val" == "" ] && val="null" || val='"'$val'"'
                errMsg+=$_br$val' 不符合 "'$opt'" 選項的預期值。'
                ;;
        esac

        args=("${args[@]:$cutLen}")
    done

    if [ "${args[0]}" == "--" ]; then
        args=("${args[@]:1}")
    else
        for val in "${args[@]}"
        do
            [ -z "`echo "_$val" | grep "^_-"`" ] && continue

            errMsg+=$_br'不符合 "[命令] [選項] [參數]" 的命令用法。'
            break
        done
    fi

    if [ -z "$errMsg" ]; then
        _args=("${args[@]}")
        return
    fi

    echo "$errMsg" | sed "1d" \
        | sed "s/^\(.\)/[$_fileName]: \1/" \
        | Loxog err
    exit 1
}

fnShowHelp() {
    local txtHelp=`fnHelp_$_shCmd`

    local bisUsage bisSubCmd bisOpt
    local usage
    bisUsage=` echo "$txtHelp" | grep "\[\[USAGE\]\]"`
    bisSubCmd=`echo "$txtHelp" | grep "\[\[SUBCMD\]\]"`
    bisOpt=`   echo "$txtHelp" | grep "\[\[OPT\]\]"`

    if [ -n "$bisUsage" ]; then
        usage="用法："
        [ -n "$bisSubCmd" ] && usage+=" [命令]"
        [ -n "$bisOpt" ] && usage+=" [選項]"

        txtHelp=`echo "$txtHelp" | sed "s/\[\[USAGE\]\]/\n$usage/"`
    fi

    [ -n "$bisSubCmd" ] && \
        txtHelp=`echo "$txtHelp" | sed "s/\[\[SUBCMD\]\]/\\n\\n命令：\\n/"`

    [ -n "$bisOpt" ] && \
        txtHelp=`echo "$txtHelp" | sed "s/\[\[OPT\]\]/\\n\\n選項：\\n/"`

    echo "$txtHelp$_br"
    exit
}


_shCmd=""
_shCmdLevel=0
_shScript "$@"
if [ $_shCmdLevel -eq 0 ]; then
    _shCmd="main"
    fnMain "$@"
    exit
fi
for tmp in `seq 0 $(( $_shCmdLevel -1 ))`
do _shCmd+="_${_args[ $tmp ]}"; done
argsShift $_shCmdLevel
_shCmd=${_shCmd:1}
fnMain_$_shCmd "${_args[@]}"

