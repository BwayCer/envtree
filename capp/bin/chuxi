#!/bin/bash
# 遠端差異比照


##shStyle ###


_originPlace="lib"

_shScript() {
    case "$1" in
    * ) ;;
    esac
}


##shStyle 介面函式


fnHelp_main() { echo "# 遠端差異比照。
[[USAGE]] <目錄位置>
[[OPT]]
      --diff     比較。
                   1. 若 \".diff.chux\" 文件不存在時，與遠端文件做比較。
                   2. 若 \".diff.chux\" 文件存在時，顯示其文件內容。
                   3. 若選用 \"--diff\" 選項，忽略上述條件，只與遠端文件
                      做比較。
      --update   更新，將儲存的文件與遠端同步。
  -h, --help     幫助。


## 遠端路徑文件
#
#    1 -> http example.com
#    2 /
#    4
#    5 -> https www.example.com
#    6 /api
#    7 /docs
#
# 在範例文件中的遠端路徑共有以下三個：
#   -> http://example.com/
#   -> https://www.example.com/api
#   -> https://www.example.com/docs
"; }
fnOpt_main() {
    case "$1" in
        --diff )
            opt_diff=1
            return 1
            ;;
        --update )
            opt_update=1
            return 1
            ;;
        -h | --help ) fnShowHelp ;;
        * ) return 3 ;;
    esac
}
fnMain() {
    opt_diff=0
    opt_update=0
    fnParseOption

    [ ${#_args[@]} -eq 0 ] && fnShowHelp

    local tmp idx len val
    local chuxiDir="${_args[ 0 ]}"

    cd "$chuxiDir"

    if [ $opt_update -eq 0 ] && [ $opt_diff -eq 0 ] && [ -f .diff.chuxi ]; then
        cat .diff.chuxi
        return
    fi

    local filename txtFile
    local protocol host curlPath pageDirPath pagePath diffTxt

    diffTxt=$_br
    fnLsList "*.chuxi"
    for filename in "${rtnLsList[@]}"
    do
        txtFile=`cat $filename`
        [ -z "$txtFile" ] && continue
        len=`echo -e "$txtFile" | wc -l`

        protocol=""
        host=""
        curlPath=""
        pageDirPath=""
        pagePath=""
        for idx in `seq 1 $len`
        do
            val=`echo "$txtFile" | sed -n "${idx}p"`

            fnCheckConfig "$protocol" "$host" "$val"
            case $? in
                2 ) continue ;;
                3 )
                    protocol="$rtnCheckConfig_protocol"
                    host="$rtnCheckConfig_host"
                    continue
                    ;;
            esac

            curlPath="$protocol://$host$val"
            Loxog war "curl \"$curlPath\""
            fnCurlContent "$protocol" "$host" "$val"
            [ $? -eq 2 ] && continue
            pageDirPath="$rtnCurlContent_pageDirPath"
            pagePath="$rtnCurlContent_pagePath"


            if [ ! -f "$pagePath" ] || [ $opt_update -eq 1 ]; then
                [ ! -f "$pageDirPath" ] && mkdir -p "$pageDirPath"
                cat response.chuxi.tmp > "$pagePath"

                diffTxt+="== diff local \"$pagePath\""$_br$_br$_br
                continue
            fi

            tmp=`cat response.chuxi.tmp | diff -ry --suppress-common-lines "$pagePath" -`
            if [ -z "$tmp" ]; then
                diffTxt+="== diff local \"$pagePath\""$_br$_br$_br
            else
                diffTxt+="<> diff local \"$pagePath\""$_br$_br
                diffTxt+=$tmp$_br
                diffTxt+=$_br$_br
            fi
        done
    done

    [ $opt_update -eq 0 ] && [ -n "`echo "$diffTxt" | grep .`" ] \
        && echo "$diffTxt" | tee .diff.chuxi

    [ -f response.chuxi.tmp ] && rm response.chuxi.tmp
    cd "$_PWD"
}


##shStyle 共享變數



##shStyle 函式庫


rtnLsList=()
fnLsList() {
    local txt len idx val
    local lsOpt="$1"
    [ "${lsOpt:0:1}" == "-" ] && shift || lsOpt=""

    local list path
    list=()

    for path in "$@"
    do
        txt=`ls $lsOpt -1 $path 2> /dev/null`
        [ $? -ne 0 ] && continue

        len=`ls $lsOpt -1 $path | wc -l`
        [ $len -eq 0 ] && continue

        for idx in `seq 1 $len`
        do
            val=`echo "$txt" | sed -n "${idx}p"`
            list[ ${#list[@]} ]=$val
        done
    done

    rtnLsList=("${list[@]}")
}

rtnCheckConfig_protocol=""
rtnCheckConfig_host=""
fnCheckConfig() {
    local protocol="$1"
    local host="$2"
    local pathname="$3"

    local rtnCode

    if [ -z "$pathname" ]; then
        protocol=""
        host=""
        rtnCode=3
    elif [ "->" == "`echo "$pathname" | cut -d " " -f 1`" ]; then
        protocol=`echo "$pathname" | cut -d " " -f 2`
        host=`    echo "$pathname" | cut -d " " -f 3`
        rtnCode=3
    fi

    if [ -z "$rtnCode" ]; then
        case "`echo "$pathname" | sed "s/\(.\).*/\1/"`" in
            / ) ;;
            "#" ) rtnCode=2 ;;
            * )
                Loxog err "  (x) \"$pathname\" 路徑錯誤。"
                rtnCode=2
                ;;
        esac
    fi

    if [ -z "$rtnCode" ]; then
        if [ -z "$protocol" ] || [ -z "$host" ]; then
            Loxog err "  (x) \"$protocol://$host$pathname\" 網址錯誤。"
            rtnCode=2
        fi
    fi

    rtnCheckConfig_protocol="$protocol"
    rtnCheckConfig_host="$host"
    return $rtnCode
}

rtnCurlContent_pageDirPath=""
rtnCurlContent_pagePath=""
fnCurlContent() {
    local tmp
    local protocol="$1"
    local host="$2"
    local pathname="$3"

    local errMsg pageDirPath pagePath
    local curlPath="$protocol://$host$pathname"

    tmp="%{http_code}\n%{content_type}"
    httpHeader=`curl -o response.chuxi.tmp -sw "$tmp" "$curlPath"`

    tmp=`echo "$httpHeader" | sed -n "1p"`
    case "$tmp" in
        2* ) ;;
        000 ) errMsg="curl error" ;;
        404 ) errMsg="HTTP 404 - Not Found" ;;
        *   ) errMsg="HTTP $tmp error" ;;
    esac
    if [ -n "$errMsg" ]; then
        Loxog err "  (x) $errMsg"
        return 2
    fi

    [ -n "`echo "$pathname" | grep '/$'`" ] \
        && pagePath=$host$pathname"index.html" \
        || pagePath=$host$pathname
    pageDirPath=`dirname "$pagePath"`

    rtnCurlContent_pageDirPath="$pageDirPath"
    rtnCurlContent_pagePath="$pagePath"
}


##shStyle 腳本環境


__filename=`realpath "$0"`
_dirsh=`dirname "$__filename"`
[ "$_originPlace" == "bin" ] && _binsh=$_dirsh || _binsh=`realpath "$_dirsh/../../bin"`
[ "$_originPlace" == "bin" ] && _libsh=`realpath "$_dirsh/../lib"` || _libsh=`realpath "$_dirsh/.."`
_fileName=`basename "$0"`

_PWD=$PWD
_br="
"

# 0 黑 black
# 1 紅 red
# 2 綠 green
# 3 黃 yellow
# 4 藍 blue
# 5 粉 magenta
# 6 青 cyan
# 7 白 white
_fColor() {
    local color=$1
    local bold=$2
    local bgcolor=$3
    local underline=$4

    [ $_fColor_usable -eq 0 ] && [ $_fColor_force -eq 0 ] && return

    if [ "$color" == "N" ]; then
        [ $_fColor_force -eq 0 ] \
            && printf "`tput sgr0`" \
            || printf "\e[00m"

        return
    fi

    case "$color" in
        [01234567] )
            [ $_fColor_force -eq 0 ] \
                && printf "`tput setaf $color`" \
                || printf "\e[3${color}m"
            ;;
    esac

    case "$bgcolor" in
        [01234567] )
            [ $_fColor_force -eq 0 ] \
                && printf "`tput setab $bgcolor`" \
                || printf "\e[4${bgcolor}m"
            ;;
    esac

    if [ "$bold" == "1" ]; then
        [ $_fColor_force -eq 0 ] \
            && printf "`tput bold`" \
            || printf "\e[01m"
    fi

    if [ "$underline" == "1" ]; then
        [ $_fColor_force -eq 0 ] \
            && printf "`tput smul`" \
            || printf "\e[04m"
    fi
}
_fColor_usable=0
_fColor_force=0

_fN=""
_fRedB=""
_fYelB=""

Loxog() {
    local _stdin=`[ ! -t 0 ] && { \
        IFS='';
        while read pipeData; do echo "$pipeData"; done <&0;
        unset IFS
    }`
    local method="$1"; shift

    local color formatArgus

    case $method in
        com ) color=$_fN    ;; # common
        war ) color=$_fYelB ;; # warn
        err ) color=$_fRedB ;; # error
    esac

    formatArgus="$color%s$_fN\n"

    local idx val len

    [ -n "$*" ] && printf "$formatArgus" "$@" 1>&2

    [ -z "$_stdin" ] && return
    len=`echo "$_stdin" | wc -l`
    for idx in `seq 1 $len`
    do
        val=`echo "$_stdin" | sed -n "${idx}p"`
        printf "$formatArgus" "$val" 1>&2
    done
}

_onCtrlC() {
    local val
    for val in "$@"
    do
        _onCtrlC_cmd+=$val$_br
    done
    trap 'sh -c "echo ; $_onCtrlC_cmd echo"; exit' 2
}
_onCtrlC_cmd=""


##shStyle ###


[ -L "$0" ] && exec "`realpath "$0"`" "$@"

_stdin=`[ ! -t 0 ] && while read pipeData; do echo $pipeData; done <&0`

_args=("$@")
_origArgs=("$@")

argsShift() {
    local amount=$1

    if [ -z "$amount" ] || [ $amount -lt 1 ]; then amount=1; fi
    _args=("${_args[@]:$amount}")
}

tmp=`tput colors`
[ -t 1 ] && [ -n "$tmp" ] && [ $tmp -ge 8 ] && _fColor_usable=1
_fnForceColor() {
    [ "$1" == 1 ] && _fColor_force=1
    _fN=`_fColor N`
    _fRedB=`_fColor 1 1`
    _fYelB=`_fColor 3 1`
}
_fnForceColor

fnParseOption() {
    local fnHandleOpt="fnOpt_$_shCmd"

    local tmp args opt val cutLen errMsg
    args=("${_args[@]}")
    errMsg=""

    while [ 1 ]
    do
        opt=${args[0]}
        val=${args[1]}
        cutLen=2

        if [ "$opt" == "--" ] || [ -z "`echo "_$opt" | grep "^_-"`" ]; then break; fi

        if [ -n "`echo "_$opt" | grep "^_-[^-]"`" ] && [ ${#opt} -ne 2 ]; then
            tmp="-"${opt:2}
            opt=${opt:0:2}
            val=""
            cutLen=1
            args=("$opt" "$tmp" "${args[@]:1}")
        elif [ -n "`echo "_$val" | grep "^_-"`" ]; then
            val=""
            cutLen=1
        fi

        if [ "$opt" == "--color" ]; then
            _fnForceColor 1
            tmp=1
        else
            $fnHandleOpt "$opt" "$val"
            tmp=$?
        fi
        case $tmp in
            0 )
                echo '請檢查 "'$fnHandleOpt'" 的錯誤回傳值。' 1>&2
                exit
                ;;
            # 使用 1 個參數
            1 )
                [ $cutLen -eq 2 ] && (( cutLen-- ))
                ;;
            # 使用 2 個參數
            2 ) ;;
            3 )
                errMsg+=$_br'找不到 "'$opt'" 選項。'
                ;;
            4 )
                [ "$val" == "" ] && val="null" || val='"'$val'"'
                errMsg+=$_br$val' 不符合 "'$opt'" 選項的預期值。'
                ;;
        esac

        args=("${args[@]:$cutLen}")
    done

    if [ "${args[0]}" == "--" ]; then
        args=("${args[@]:1}")
    else
        for val in "${args[@]}"
        do
            [ -z "`echo "_$val" | grep "^_-"`" ] && continue

            errMsg+=$_br'不符合 "[命令] [選項] [參數]" 的命令用法。'
            break
        done
    fi

    if [ -z "$errMsg" ]; then
        _args=("${args[@]}")
        return
    fi

    echo "$errMsg" | sed "1d" \
        | sed "s/^\(.\)/[$_fileName]: \1/" \
        | Loxog err
    exit 1
}

fnShowHelp() {
    local txtHelp=`fnHelp_$_shCmd`

    local bisUsage bisSubCmd bisOpt
    local usage
    bisUsage=` echo "$txtHelp" | grep "\[\[USAGE\]\]"`
    bisSubCmd=`echo "$txtHelp" | grep "\[\[SUBCMD\]\]"`
    bisOpt=`   echo "$txtHelp" | grep "\[\[OPT\]\]"`

    if [ -n "$bisUsage" ]; then
        usage="用法："
        [ -n "$bisSubCmd" ] && usage+=" [命令]"
        [ -n "$bisOpt" ] && usage+=" [選項]"

        txtHelp=`echo "$txtHelp" | sed "s/\[\[USAGE\]\]/\n$usage/"`
    fi

    [ -n "$bisSubCmd" ] && \
        txtHelp=`echo "$txtHelp" | sed "s/\[\[SUBCMD\]\]/\\n\\n命令：\\n/"`

    [ -n "$bisOpt" ] && \
        txtHelp=`echo "$txtHelp" | sed "s/\[\[OPT\]\]/\\n\\n選項：\\n/"`

    echo "$txtHelp$_br"
    exit
}


_shCmd=""
_shCmdLevel=0
_shScript "$@"
if [ $_shCmdLevel -eq 0 ]; then
    _shCmd="main"
    fnMain "$@"
    exit
fi
for tmp in `seq 0 $(( $_shCmdLevel -1 ))`
do _shCmd+="_${_args[ $tmp ]}"; done
argsShift $_shCmdLevel
_shCmd=${_shCmd:1}
fnMain_$_shCmd "${_args[@]}"

